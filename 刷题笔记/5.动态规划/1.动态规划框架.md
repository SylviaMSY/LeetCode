## 动态规划框架

> 写出暴力解，用备忘录（递归）或DP table（迭代）优化

#### 1 原理：

- 场景：求最值问题（最大值、最小值）
- 核心：穷举
- 优化：存在【重叠子问题】，需要用【备忘录】或【DP table】来优化
- 具备【最优子结构】，通过子问题的最值，得到原问题的最值

#### 2 动态规划三要素：

- 重叠子问题：重复计算的部分，可建备忘录，计算前先查询
- 最优子结构：子问题间相互独立，由子问题推出原问题的解
- 状态转移方程：描述问题结构的数学形式，代表暴力解法

#### 3 动态规划与递归的区别：

- ##### 递归：自顶向下

- ##### 动态规划：自底向上，递推求解。（循环迭代完成）

#### 4 动态规划的优化

- **时间复杂度：**通过memo或DP-table来剪枝（即重叠子问题）
- **空间复杂度：**通过缩小DB-table的大小（如果发现状态转移每次只需要DP-table的一部分，则可以动态更新DP-table）



### 二  

#### 1 框架：

``` java
// 初始化 base case
dp[0][0][…] = base
// 进行状态转移
for 状态1 in 状态1的所有值：
    for 状态2 in 状态2的所有值：
        for ......：
            dp[0][0][…] = 求最值（选择1，选择2，…）
```

#### 2 解题步骤

1. **确定base case**
2. **确定【状态】**：原问题和子问题中会变化的量
3. **确定【选择】**：导致【状态】发生变化的行为
4. **明确dp函数/数组的定义**

#### 3 思路

1. 穷举法/暴力搜索

   - 穷举、画递归树、尝试写递归函数

2. 记忆化搜索/剪枝

   - memo备忘录

3. 改写成迭代形式

   - 将计算过程画出来，观察公式求解的顺序：自顶向下，还是自底向上
   - 将递归改写成迭代形式
   - 滚动dp：优化空间复杂度

   

##### 伪码框架：

``` java
int coinChange(int[] coins, int amount){
    // 题目要求最终结果是 dp[amount]
    return dp[coins,amount]
}

// 定义：要凑出金额n，至少要dp[coins,n]个硬币
int dp(int[] coins, int n){
    // 做选择，选择需要硬币最少的那个结果
    for(int coin : coins){
        res = min(res, 1+dp(n-coin))
    }
    return res
}
```

